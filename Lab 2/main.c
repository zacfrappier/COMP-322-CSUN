/*
Zachary Frappier
Comp 322 Lab 2 
Prof Ebrahimi
*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// declare global variables including a table structure to hold scheduling information
typedef struct process_table{
	int id;					// will be autogenerated
	int arrival_cycle;		// arrival time		
	int total_cycle;		// cpu burst
	int total_remaining;	// for SRT
	int done_flag; 				// for flag
	int start_time;			// p starts execution
	int start_flag;			//marks if started
	int end_time;			// execution finished
	int turnaround_time; 	// will be end - arrival 
} Process;

//initialize table
Process *g_processes = NULL;
int g_num_processes = 0;

// optional: define a function that finds the maximum of two integers
int find_max(int int1,int int2){
	if(int1 <= int2){ 
		return int2;
	}else{
		return int1;
	}	
}

//***************************************************************
void print_table() {
	printf("\nPID		Arrival	Total	Start	End	Turnaround\n");
	printf("----------------------------------------------\n");

	for (int i = 0; i < g_num_processes; i++){
		printf("%-3d %-7d %-5d",	//adds padding to each number
			g_processes[i].id,
			g_processes[i].arrival_cycle,
			g_processes[i].total_cycle); 
		//print finished processes
		if(g_processes[i].done_flag == 1){
			printf(" %-5d %-3d %-10d \n",
			g_processes[i].start_time,
			g_processes[i].end_time,
			g_processes[i].turnaround_time);
		}else{
			printf(" no data to show\n");
		}	
	}
	printf("\n");	
	return;
}


//************************************************************* Proc 1
void parameters() { 
	printf("Enter number of proceses: \n");
	scanf("%d", &g_num_processes);

	g_processes =(Process *)malloc(g_num_processes * sizeof(Process));
	if (g_processes == NULL){
		perror("Failed to allocate memory");
		g_num_processes = 0;
		return;
	}

	for(int i =0; i < g_num_processes; i++){
		g_processes[i].id = i + 1;
		printf("Enter arrival cycle for process %d: ", g_processes[i].id);
		scanf("%d", &g_processes[i].arrival_cycle);
		printf("Enter total cycles for process %d: ", g_processes[i].id);
		scanf("%d", &g_processes[i].total_cycle);
		//aut set all others
		g_processes[i].done_flag = 0;
		g_processes[i].total_remaining = g_processes[i].total_cycle;
		g_processes[i].start_time = -1;
		g_processes[i].start_flag = 0;
		g_processes[i].end_time = -1;
		g_processes[i].turnaround_time = -1;
	}

	print_table();
	return;		
}	
		

//************************************************************* Proc 2
void fifo() {
	// declare (and initilize when appropriate) local variables 
	// for each process, reset "done" field to 0 
	// while there are still processes to schedule 	
		// initilize the earliest arrival time to INT_MAX (largest integer value) 
		// for each process not yet scheduled 
			// check if process has earlier arrival time than current earliest and update 	
		// set start time, end time, turnaround time, done fields for unscheduled process with earliest arrival time        	
		// update current cycle time and increment number of processes scheduled 
	// print contents of table 
	return;		
}	


//************************************************************* Proc 3
void sjf() {
	// declare (and initilize when appropriate) local variables 
	// for each process, reset "done" field to 0 
	// while there are still processes to schedule 	
		// initilize the lowest total cycle time to INT_MAX (largest integer value) 
		// for each process not yet scheduled 
			// check if process has lower total cycle time than current lowest and has arrival time less than current cycle time and update 	
		// set start time, end time, turnaround time, done fields for unscheduled process with lowest (and available) total cycle time        	
		// update current cycle time and increment number of processes scheduled 
	// print contents of table 
	return;		
}	
        	

//************************************************************* Proc 4
void srt() {
	// declare (and initilize when appropriate) local variables 
	// for each process, reset "done", "total_remaining" and "already_started" fields to 0 
	// while there are still processes to schedule 	
		// initilize the lowest total remaining time to INT_MAX (largest integer value) 
		// for each process not yet scheduled 
			// check if process has lower total remaining time than current lowest and has arrival time less than current cycle time and update 	
		// check if process already partially-scheduled 
			// if so, set "start time", "already_started" fields of process with lowest (and available) total remaining cycle time        	
		// set end time, turnaround time of process with lowest (and available) total remaining cycle time 
		// decrement total remaining time of process with lowest (and available) total remaining cycle time 
		// if remaining time is 0, set done field to 1, increment cycle time and number of scheduled processes
	// print contents of table 
	return;		
}	
        	

//*************************************************************
void exit_free_mem() {
	// free the schedule table if not NULL 
	return;
}


//*************************************************************
int main() {
    printf("Welcome to Lab2! \n Objective: show common scheduling algorithms FIFO, SJF, and SRT\n");
	// declare local vars 
    int choice;
    do{
        printf("---Menu---\n");
        printf("1) Enter Parameters (Processes with arrival and total cycles)\n");
        printf("2) Schedule processes with FIFO algorithm \n");
        printf("3) Schedule processes with SJF algorithm \n");
        printf("4) Schedule processes with SRT algorithm  \n");
		printf("5) Exit & free mem");
		scanf("%d", &choice);

		switch(choice){
			case 1:
				printf("you selected to input parameters\n");
				parameters();
				break;
			case 2: 
				printf("you selected to schedule FIFO\n");
				fifo();
				break;
			case 3:
				printf("you selected to schedule SJF\n");
				sjf();
				break;
			case 4: 
				printf("you selected to schedule SRT\n");
				srt();
				break;
			case 5:
				printf("you selected to exit\n");
				exit_free_mem();
				exit(0);			
		}

    }while(choice != 5);
	 return 1; // indicates success 
} // end of procedure 