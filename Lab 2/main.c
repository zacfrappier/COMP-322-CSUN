/*
Zachary Frappier
Comp 322 Lab 2 
Prof Ebrahimi
*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// declare global variables including a table structure to hold scheduling information
typedef struct process_table{
	int id;					// will be autogenerated
	int arrival_cycle;		// arrival time		
	int total_cycle;		// cpu burst
	int total_remaining;	// for SRT
	int done_flag; 				// for flag
	int start_time;			// p starts execution
	int start_flag;			//marks if started
	int end_time;			// execution finished
	int turnaround_time; 	// will be end - arrival 
} Process;

//initialize table
Process *g_processes = NULL;
int g_num_processes = 0;

// optional: define a function that finds the maximum of two integers
int find_max(int int1,int int2){
	if(int1 <= int2){ 
		return int2;
	}else{
		return int1;
	}	
}

//***************************************************************
void print_table() {
	printf("\nPID		Arrival	Total	Start	End	Turnaround\n");
	printf("----------------------------------------------\n");

	for (int i = 0; i < g_num_processes; i++){
		printf("%-3d %-7d %-5d",	//adds padding to each number
			g_processes[i].id,
			g_processes[i].arrival_cycle,
			g_processes[i].total_cycle); 
		//print finished processes
		if(g_processes[i].done_flag == 1){
			printf(" %-5d %-3d %-10d \n",
			g_processes[i].start_time,
			g_processes[i].end_time,
			g_processes[i].turnaround_time);
		}else{
			printf(" no data to show\n");
		}	
	}
	printf("\n");	
	return;
}


//************************************************************* Proc 1
void parameters() { 
	printf("Enter number of proceses: \n");
	scanf("%d", &g_num_processes);

	g_processes =(Process *)malloc(g_num_processes * sizeof(Process));
	if (g_processes == NULL){
		perror("Failed to allocate memory");
		g_num_processes = 0;
		return;
	}

	for(int i =0; i < g_num_processes; i++){
		g_processes[i].id = i + 1;
		printf("Enter arrival cycle for process %d: ", g_processes[i].id);
		scanf("%d", &g_processes[i].arrival_cycle);
		printf("Enter total cycles for process %d: ", g_processes[i].id);
		scanf("%d", &g_processes[i].total_cycle);
		//aut set all others
		g_processes[i].done_flag = 0;
		g_processes[i].total_remaining = g_processes[i].total_cycle;
		g_processes[i].start_time = -1;
		g_processes[i].start_flag = 0;
		g_processes[i].end_time = -1;
		g_processes[i].turnaround_time = -1;
	}

	print_table();
	return;		
}	
		

//************************************************************* Proc 2 First In First Out
void fifo() {
	if(g_num_processes == 0 || g_processes == NULL){
		printf("Go back to option 1\n");
		return;
	}
	//local v's
	int current_cycle = 0, scheduled_count = 0, next_process_index, i, earliest_arrival, next_arrival, found_next;
	//reset done_flag
	for( i = 0; i < g_num_processes; i++){
		g_processes[i].done_flag = 0;
	}
	//while loop processes to schedule
	while(scheduled_count < g_num_processes){
		next_process_index = -1;
		earliest_arrival = INT_MAX;
		//find earliest arrival time
		for(i=0; i < g_num_processes; i++){ 
			if (g_processes[i].done_flag == 0){	// check to see if complete yet
				if(g_processes[i].arrival_cycle <= current_cycle){  // check current cycle matches
					if(g_processes[i].arrival_cycle < earliest_arrival){	//check that time 
						earliest_arrival = g_processes[i].arrival_cycle;
						next_process_index = i;
					}
				}
			}
		}
	}
	//scheduling of processes * pointer for structure 'shorthand' method
	if(next_process_index != -1){
		Process *p = &g_processes[next_process_index];
		p->start_time = current_cycle;
		p->end_time = p->start_time + p->total_cycle;
		p->turnaround_time = p->end_time - p->arrival_cycle;
		p->done_flag = 1;

		current_cycle = p->end_time;
		scheduled_count++;
	}else{
		next_arrival = INT_MAX;
		found_next = 0;
		for( i = 0; i < g_num_processes; i++){
			if(g_processes[i].done_flag == 0 && g_processes[i].arrival_cycle < next_arrival){
				next_arrival = g_processes[i].arrival_cycle;
				found_next = 1;
			}
		}
		// checks system idle time
		if(found_next && current_cycle < next_arrival){
			current_cycle = next_arrival;
		}else{
			current_cycle++;
		}
	}
	print_table();

 	
		// initilize the earliest arrival time to INT_MAX (largest integer value) 
		// for each process not yet scheduled 
			// check if process has earlier arrival time than current earliest and update 	
		// set start time, end time, turnaround time, done fields for unscheduled process with earliest arrival time        	
		// update current cycle time and increment number of processes scheduled 
	// print contents of table 
	return;		
}	


//************************************************************* Proc 3 Shortest Job First
void sjf() {
	if(g_num_processes == 0 || g_processes == NULL){
		printf("Go back to option 1\n");
		return;
	}
	int current_cycles = 0, scheduled_count = 0, i, next_process_index, lowest_cpu_time, next_arrival, found_next;
	//reset done flag
	for (i = 0; i < g_num_processes; i++){
		g_processes[i].done_flag = 0;
	}
	while (scheduled_count < g_num_processes){ // start the cycles
		next_process_index = -1;
		lowest_cpu_time = INT_MAX;
		for(i = 0; i < g_num_processes; i++){ //loop the programs 
			if(g_processes[i].done_flag == 0){
				if(g_processes[i].arrival_cycle <= current_cycles){
					lowest_cpu_time = g_processes[i].total_cycle;
					next_process_index = i;
				}else if(g_processes[i].total_cycle == lowest_cpu_time){
					// Tie-breaking: Use FIFO (earlier arrival) or PID (lower ID)
                        if (g_processes[i].arrival_cycle < g_processes[next_process_index].arrival_cycle) {
                             next_process_index = i;
                        } else if (g_processes[i].arrival_cycle == g_processes[next_process_index].arrival_cycle && g_processes[i].id < g_processes[next_process_index].id) {
                            next_process_index = i;
                        }
				}
			}
		}
	}
	//next process - should be set from previous 
	if(next_process_index != -1){
		Process *p = &g_processes[next_process_index];
		p->start_time = current_cycles;
		p->end_time = p->start_time + p->total_cycle;
		p->turnaround_time = p->end_time - p->arrival_cycle;
		p->done_flag = 1;
		current_cycles = p->end_time;
		scheduled_count++;
	}else{
		next_arrival = INT_MAX;
		found_next = 0;
		for( i=0; i < g_num_processes; i++){
			if(g_processes[i].done_flag == 0 && g_processes[i].arrival_cycle < next_arrival){
				next_arrival = g_processes[i].arrival_cycle;
				found_next = 1;
			}
		}
		if( found_next && next_arrival > current_cycles){
			current_cycles = next_arrival;
		}else{
			current_cycles++;
		}
	}
	print_table();

	return;		
}	
        	

//************************************************************* Proc 4
void srt() {
	if (g_num_processes == 0 || g_processes == NULL) {
        printf("Please enter parameters first (Option 1).\n");
        return;
    }
	//locals
    int i, current_cycle = 0, scheduled_count = 0, current_process_index = -1, best_process_index, lowest_remaining;
    // Reset all scheduling-related fields
    for (i = 0; i < g_num_processes; i++) {
        g_processes[i].done_flag = 0;
        g_processes[i].total_remaining = g_processes[i].total_cycle; // Reset remaining time
        g_processes[i].start_flag = 0;
        g_processes[i].start_time = -1;
        g_processes[i].end_time = -1;
        g_processes[i].turnaround_time = -1;
    }
	while(scheduled_count = 0 < g_num_processes ){
		best_process_index = -1;
		lowest_remaining = INT_MAX;
		for(i=0; i < g_num_processes; i++){
			if(g_processes[i].done_flag == 0 && g_processes[i].arrival_cycle <= current_cycle ){
				
			}
		}
	}
	return;		
}	
        	

//*************************************************************
void exit_free_mem() {
	// free the schedule table if not NULL 
	return;
}


//*************************************************************
int main() {
    printf("Welcome to Lab2! \n Objective: show common scheduling algorithms FIFO, SJF, and SRT\n");
	// declare local vars 
    int choice;
    do{
        printf("---Menu---\n");
        printf("1) Enter Parameters (Processes with arrival and total cycles)\n");
        printf("2) Schedule processes with FIFO algorithm \n");
        printf("3) Schedule processes with SJF algorithm \n");
        printf("4) Schedule processes with SRT algorithm  \n");
		printf("5) Exit & free mem");
		scanf("%d", &choice);

		switch(choice){
			case 1:
				printf("you selected to input parameters\n");
				parameters();
				break;
			case 2: 
				printf("you selected to schedule FIFO\n");
				fifo();
				break;
			case 3:
				printf("you selected to schedule SJF\n");
				sjf();
				break;
			case 4: 
				printf("you selected to schedule SRT\n");
				srt();
				break;
			case 5:
				printf("you selected to exit\n");
				exit_free_mem();
				exit(0);			
		}

    }while(choice != 5);
	 return 1; // indicates success 
} // end of procedure 